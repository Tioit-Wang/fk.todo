name: release

on:
  push:
    tags:
      - "V*"

jobs:
  guard:
    name: Guard (release branch)
    runs-on: ubuntu-24.04
    outputs:
      ok: ${{ steps.guard.outputs.ok }}
      release_ref: ${{ steps.guard.outputs.release_ref }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - id: guard
        name: Ensure tag points to release branch
        shell: bash
        run: |
          set -euo pipefail

          # Ensure the release tag points to a commit reachable from the release branch.
          # Prefer "master" if it exists; otherwise fall back to "main".
          git fetch origin --prune --tags

          tag="${GITHUB_REF_NAME}"
          if [[ ! "$tag" =~ ^V[0-9]{8}\.[0-9]+\.[0-9]+(-bate(\.[0-9]+)?)?$ ]]; then
            echo "Invalid release tag: ${tag}" >&2
            echo "Expected: VYYYYMMDD.N.P or VYYYYMMDD.N.P-bate[.N]" >&2
            exit 1
          fi

          version="${tag#V}"
          python3 - "$version" <<'PY'
          import json
          import pathlib
          import sys

          try:
              import tomllib  # Python >= 3.11
          except Exception as exc:  # pragma: no cover
              print(f"tomllib is required to parse Cargo.toml: {exc}", file=sys.stderr)
              sys.exit(1)

          tag_version = sys.argv[1]
          root = pathlib.Path(".")

          def read_json(path: str) -> dict:
              return json.loads((root / path).read_text(encoding="utf-8"))

          def read_toml(path: str) -> dict:
              return tomllib.loads((root / path).read_text(encoding="utf-8"))

          pkg_version = read_json("todo-tool/package.json").get("version")
          tauri_version = read_json("todo-tool/src-tauri/tauri.conf.json").get("version")
          cargo = read_toml("todo-tool/src-tauri/Cargo.toml")
          cargo_version = (cargo.get("package") or {}).get("version")

          versions = {
              "todo-tool/package.json": pkg_version,
              "todo-tool/src-tauri/Cargo.toml": cargo_version,
              "todo-tool/src-tauri/tauri.conf.json": tauri_version,
          }

          missing = [path for path, v in versions.items() if not isinstance(v, str) or not v.strip()]
          if missing:
              print("Failed to read version from:", file=sys.stderr)
              for path in missing:
                  print(f"  - {path}", file=sys.stderr)
              sys.exit(1)

          unique_versions = set(versions.values())
          if len(unique_versions) != 1:
              print("Version mismatch between files:", file=sys.stderr)
              for path, v in versions.items():
                  print(f"  {path}: {v}", file=sys.stderr)
              sys.exit(1)

          file_version = next(iter(unique_versions))
          if file_version != tag_version:
              print("Tag/version mismatch:", file=sys.stderr)
              print(f"  tag: {tag_version}", file=sys.stderr)
              for path, v in versions.items():
                  print(f"  {path}: {v}", file=sys.stderr)
              sys.exit(1)

          print(f"Version OK: {tag_version}")
          PY

          release_ref=""
          if git show-ref --verify --quiet refs/remotes/origin/master; then
            release_ref="origin/master"
          elif git show-ref --verify --quiet refs/remotes/origin/main; then
            release_ref="origin/main"
          else
            echo "Neither origin/master nor origin/main exists; cannot determine release branch." >&2
            exit 1
          fi

          echo "release_ref=$release_ref" >> "$GITHUB_OUTPUT"

          if git merge-base --is-ancestor "${GITHUB_SHA}" "${release_ref}"; then
            echo "ok=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "ok=false" >> "$GITHUB_OUTPUT"
          echo "Tag ${GITHUB_REF_NAME} must point to a commit that is on ${release_ref}." >&2
          exit 1

  publish:
    name: Publish (${{ matrix.platform }})
    needs: guard
    if: needs.guard.outputs.ok == 'true'
    runs-on: ${{ matrix.platform }}
    permissions:
      contents: write
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: ubuntu-24.04
            args: "--bundles appimage"
          - platform: windows-2022
            args: "--bundles nsis"
          - platform: macos-14
            args: "--target aarch64-apple-darwin --bundles dmg"
          - platform: macos-14
            args: "--target x86_64-apple-darwin --bundles dmg"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: npm
          cache-dependency-path: todo-tool/package-lock.json

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Install macOS targets
        if: runner.os == 'macOS'
        run: rustup target add aarch64-apple-darwin x86_64-apple-darwin

      - name: Rust cache
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: |
            todo-tool/src-tauri -> todo-tool/src-tauri/target

      - name: Install Linux dependencies (Tauri)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            pkg-config \
            libssl-dev \
            libgtk-3-dev \
            libwebkit2gtk-4.1-dev \
            libayatana-appindicator3-dev \
            librsvg2-dev \
            patchelf

      - name: Install frontend dependencies
        working-directory: todo-tool
        run: npm ci

      - name: Build and publish
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        with:
          projectPath: todo-tool
          tagName: ${{ github.ref_name }}
          releaseName: fk.todo ${{ github.ref_name }}
          releaseBody: See the assets to download this version and install.
          # IMPORTANT:
          # - Release assets are uploaded by each platform job in parallel.
          # - If we publish the release as "latest" immediately, users may fetch an incomplete
          #   latest.json while the matrix is still running (and the updater will fail).
          # - We therefore keep the release as a draft and only finalize it (including latest.json)
          #   in the dedicated `finalize` job once all platform builds are complete.
          releaseDraft: true
          prerelease: false
          includeUpdaterJson: false
          updaterJsonPreferNsis: true
          args: ${{ matrix.args }}

  finalize:
    name: Finalize (latest.json + publish)
    needs: [guard, publish]
    if: needs.guard.outputs.ok == 'true'
    runs-on: ubuntu-24.04
    permissions:
      contents: write
    steps:
      - name: Generate and upload latest.json, then publish release
        uses: actions/github-script@v7
        with:
          script: |
            const tag = process.env.GITHUB_REF_NAME;
            if (!tag || !tag.startsWith("V")) {
              core.setFailed(`unexpected tag: ${tag}`);
              return;
            }
            const version = tag.slice(1);
            const isPrerelease = /-bate(\.|$)/.test(version);

            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const { data: release } = await github.rest.repos.getReleaseByTag({
              owner,
              repo,
              tag,
            });

            const assets = release.assets ?? [];
            const byName = new Map(assets.map((a) => [a.name, a]));
            const must = (name) => {
              const asset = byName.get(name);
              if (!asset) throw new Error(`missing release asset: ${name}`);
              return asset;
            };

            // We currently publish updater artifacts for Windows (NSIS) and Linux (AppImage).
            // macOS DMG is shipped as an installer, but we don't publish a signed updater artifact for it yet.
            const winExe = must(`MustDo_${version}_x64-setup.exe`);
            const winSig = must(`MustDo_${version}_x64-setup.exe.sig`);
            const linuxExe = must(`MustDo_${version}_amd64.AppImage`);
            const linuxSig = must(`MustDo_${version}_amd64.AppImage.sig`);

            const fetchBase64 = async (url) => {
              const res = await fetch(url, {
                headers: {
                  // GitHub sometimes requires a UA for raw downloads.
                  "User-Agent": "fk.todo-release-finalize",
                },
                redirect: "follow",
              });
              if (!res.ok) {
                throw new Error(`failed to download ${url}: ${res.status} ${res.statusText}`);
              }
              const buf = Buffer.from(await res.arrayBuffer());
              return buf.toString("base64");
            };

            const winSigB64 = await fetchBase64(winSig.browser_download_url);
            const linuxSigB64 = await fetchBase64(linuxSig.browser_download_url);

            const publishedAt = release.published_at || new Date().toISOString();
            const notes = (release.body && String(release.body).trim()) || "See the assets to download this version and install.";

            const manifest = {
              version,
              notes,
              pub_date: publishedAt,
              platforms: {
                "windows-x86_64": {
                  url: winExe.browser_download_url,
                  signature: winSigB64,
                },
                "linux-x86_64": {
                  url: linuxExe.browser_download_url,
                  signature: linuxSigB64,
                },
              },
            };

            const latestJson = Buffer.from(JSON.stringify(manifest, null, 2) + "\n", "utf8");

            // Replace existing latest.json if present.
            const existing = assets.find((a) => a.name === "latest.json");
            if (existing) {
              await github.rest.repos.deleteReleaseAsset({ owner, repo, asset_id: existing.id });
            }

            await github.rest.repos.uploadReleaseAsset({
              owner,
              repo,
              release_id: release.id,
              name: "latest.json",
              data: latestJson,
              headers: {
                "content-type": "application/json",
                "content-length": latestJson.length,
              },
            });

            // Publish the release only after latest.json is complete.
            await github.rest.repos.updateRelease({
              owner,
              repo,
              release_id: release.id,
              draft: false,
              prerelease: isPrerelease,
              // Don't let preview tags override /releases/latest.
              make_latest: isPrerelease ? "false" : "true",
            });
